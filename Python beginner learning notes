# By Illusekr/Ar1sa
# Version 1.0.4 Updated at 10/20/2023 21:07


# #Chp 5 输出函数print
# #将数据输出到文件中
# fp=open('D:/text.txt','a+')
# print('hello world',file=fp)
# fp.close()

# #Chp 6 转义字符
# print('老师说：\'大家好。\'')

# #Chp 7 二进制与字符编码
# print(chr(0b100111001011000))#将各种进制数字转换成字符码（0b表示二进制）
# print(ord('乘'))#将字符码转换为十进制数

# #Chp 8 python中的标识符与保留字
# import keyword
# print(keyword.kwlist)
# #标识符不能以数字开头，不能是保留字

# #Chp 9 变量的定义和使用
# name='玛利亚'
# print(name)
# #变量由标识（内存地址）类型（数据类型）和值构成
# #使用id()获取内存地址，使用type()获取数据类型
# print('标识',id(name))
# print('类型',type(name))
# print('值',name)

#Chp 10 多次赋值
#再次赋值之后变量名会指向新的空间
# name1='maria'
# print(name1)
# name1='saksa'
# print(name1)

#Chp 11 变量类型
#int 整数类型
#float 浮点类型
#bool 布尔类型
#str 字符串类型

# Chp 12 整数类型
# print('十进制',118)
# print('二进制',0b10101111)
# print('八进制',0o176)
# print('十六进制',0x1eaf)

#Chp 13 浮点类型
# a=3.14159
# print(a,type(a))
# #浮点数计算导出位数可能不精确
# n1=1.1
# n2=2.2
# n3=2.1
# print(n1+n2)
# print(n1+n3)
# #解决方法，导入Decimal模块
# from decimal import Decimal
# print(Decimal('1.1')+Decimal('2.2'))

# # Chp 14 布尔类型
# f1=True
# f2=False
# print(f1,type(f1))
# print(f2,type(f2))

# Chp 15 字符串类型
#单引号和双引号定义的字符串必须在一行，三引号定义的可以分布在连续的多行
# str1='人生苦短，我用Python'
# print(str1,type(str1))
# str2="人生苦短，我用Python"
# str3="""人生苦短，
# 我用Python"""
# str4='''人生苦短，
# 我用Python'''
# print(str3,str4)

# Chp 16 数据类型转换
# name='张三'
# age=20
# print(type(name),type(age))
# print('我叫'+name+'今年'+str(age)+'岁')#str强制类型转换成字符串
# #int()转换整形，float()转换浮点
#只有整数字符串能转换为整形，小数串不行
#只有整数串能转成浮点类型，转换后会加上.0

# Chp 18 注释
#单行注释以#号开头，直到换行结束
# 一对三引号之间的代码称为多行注释
# 编码声明注释(在文件开头)
# #coding:gbk
# 将默认编码改为ANSI(包含gbk)

# Chp 19 输入函数
#输入值的类型为str
# present=input('大圣想要什么礼物呢？')
# print(present,type(present))

# Chp 20
# a=input('请输入一个加数')
# b=input('请输入另一个加数')
# print(int(a)+int(b))

# Chp 21 算数运算符
# print(1+1)#加减乘除运算
# print(1-1)
# print(1*2)
# print(1/2)
# print(11//2)#整除运算
# print(11%2)#取模运算
# print(2**3)#幂运算
# #一正一负的整除与取模运算
# print(9//-4)
# print(-9//4)#本质取整运算是把小数向下取整，故-2.2取-3
# print(9%-4)#本质是被除数-除数*商
# print(-9%4)

# Chp 22 赋值运算符
# 从右至左运行
#支持链式赋值 a=b=c=20 此时a,b,c的值，类型，地址都一致
#支持参数赋值 += -+ *= /= 等等 a+=30相当于a加上30在赋值给a
# 支持系列解包赋值 a,b,c=20,30,40 将20赋值给a，30赋给b，40赋给c
# 交换变量的值
# a,b=10,20
# print(a,b)
# a,b=b,a
# print(a,b)

# Chp 23 比较运算符
# # 结果为布尔值
# a,b=10,20
# print(a>b)
# print(a<b)
# print(a==b)
# print(a!=b)
#==比较的是两个对象的值
# 比较两个对象的标识的是is
# a=10
# b=10
# print(a==b)
# print(a is b)
# lst1=[11,22,33,44]
# lst2=[11,22,33,44]
# print(lst1==lst2)
# print(lst1 is lst2)#两个相同值的列表地址不同
# print(a is not b)#比较地址不等

# Chp 24 布尔运算符
# a,b=1,2
# print(a==1 and b==2)#同真则真，一假则假(与运算）
# print(a!=1 or b==2 )#一真则真，同假则假（或运算）
# f1=True
# f2=False
# print(not f1)
# print(not f2)#对布尔类型的状态取反
# s='hello world'
# print('w' in s)
# print('w' not in s)#查询一个元素在不在某对象中

# Chp 25 位运算符
# 按位与& 对应全为1才为1，否则为0
# 按位或| 对应全为0才为0，否则为1
# 左移位运算符<< 高位溢出舍弃，低位补0
# 右移位运算符>> 低位溢出舍弃，高位补0
# print(4&8) #00001000按位与00001000 与完全为0
# print(4|8)
# print(4<<1)
# print(4>>1)#二进制左移x位就是乘以2的x次方(不考虑溢出），右移则是除(也不考虑溢出）

# Chp 26 运算符的优先级
# 幂运算>乘除>加减>左移右移>按位与按位或>比较运算>布尔运算>赋值运算
# 有括号先算括号

# Chp 27 程序的组织结构
# 程序从上到下顺序执行代码，中间没有任何跳转和结束
# print('------------程序开始------------')
# print('1.把冰箱门打开')
# print('2.把大象放进冰箱里')
# print('3.把冰箱门关上')
# print('------------程序结束------------')

# Chp 28 对象的布尔值
# 使用内置函数bool()获取对象的布尔值
# 空对象，0，False，None的布尔值为False，其余都为True

# Chp 29 选择结构 单分支结构
# money=1000
# s=int(input('请输入取款金额'))
# if money>=s:
#     money=money-s
#     print('取款成功，余额为',money)

# Chp 30 选择结构 双分支结构
# num=int(input('请输入一个整数'))
# if num%2==0:
#     print('是偶数')
# else:
#     print('是奇数')

# Chp 31 选择结构 多分支结构
# 程序略
# 语法结构
# if:pass
#   pass
# elif:pass
#   pass
# elif:pass
#   pass
# else:
#     pass

# Chp 32 分支结构 嵌套if的使用
# 程序略
# 语法结构略

# Chp 33 条件表达式
# 语法结构
# x if exp1 else exp2

# Chp 34 pass语句
# 在还没有写代码的地方用作占位符

# Chp 35 range()函数的使用
# 用于生成一个整数序列
# 三种创建方式
# r=range(10)#默认从0开始，相差1为步长
# # 返回值是一个迭代器对象
# print(list(r))
# # 用于查看range对象当中的整数序列
# r=range(1,10)#指定了起始值和终止值，从1开始到10结束（不包含10）
# print(list(r))
# r=range(1,10,2)#指定了起始值，终止值和步长，相差为2
# print(list(r))
# # 判断指定的整数在序列中是否存在用 in和not in
# print(9 in r)
# 优点：不论想产生大的整数序列，只用最多三个值表示，且占用内存相等
# 只有当用到range对象时，才会去计算range中的元素

# Chp 36 while循环
# 语法结构
# while pass:
    # pass
# while判断n+1次，条件为真执行n次

# Chp 37 练习加和1到100以内的所有偶数
# 略
# 一种使用range的方法
# print(sum(range(1,100,2)))

# Chp 38 for-in循环
# in表达从字符串，序列中依次取值，又称为遍历
# 遍历的对象必须是可迭代对象
# 语法结构
# for 自定义变量 in 可迭代对象：
#     pass
# for item in 'Python':#将字符从字符串中依次取出
#     print(item)
# for i in range(10):
#     print(i)
# #如果在循环体中不需要用到自定义变量，则可将自定义变量定义为_
# for _ in range(5):
#     print('人生苦短，我用Python')
# sum=0
# for item in range(1,101):
#     if item%2==0:
#         sum+=item
# print('偶数和为：',sum)

# Chp 39 练习求100到999之间的水仙花数
# for i in range(101,1000):
#     if (i%10)**3+((i//10)%10)**3+(i//100)**3==i:
#         print(i)
# 第二种实现方法
# for a in range(1,10):
#     for b in range(0,10):
#         for c in range(0,10):
#             if a**3+b**3+c**3==int(str(a)+str(b)+str(c)):
#                 print(a**3+b**3+c**3)

# Chp 40 流程控制语句break
# 用于结束循环结构，通常与分支结构if一起使用(while也可以)
# 代码略

# Chp 41 流程控制语句continue
# 用于结束当前循环，进入下一次循环
# 代码略

# Chp 42 else语句
# 和while，for搭配时：
# 没有遇到break的时候正常在循环结束后执行，一旦break跳出则不执行
# for _ in range(3):
#     pwd=input('请输入密码')
#     if pwd == '8888':
#         break
#     else:
#         print('密码不正确')
# else:
#     print('对不起，三次密码均输入错误')
    # 换成while同理

# Chp 43 嵌套循环
# 代码略

# Chp 44 二重循环中的break和continue
# break和continue只用于控制本层循环，对外层无影响

# Chp 45 为什么需要列表
# 列表相当于其他语言中的数组,但是可以存储不同类型的元素
# 存储n个数据方便程序对这些数据进行整体操作
# lst=['hello','world',98]
# print(id(lst))
# print(type(lst))
# print(lst)

# Chp 46 列表对象的创建
# 使用[]，元素之间使用逗号分隔
# lst=['hello','world']
# # 使用内置函数list()
# lst2=list(['hello','world'])
# print(lst,lst2)

# Chp 47 列表的特点
# 列表元素按顺序有序排序
# 索引映射唯一一个数据
# 可以重复储存数据
# 任意数据类型混存
# 可以根据需要动态分配和回收内存

# Chp 48 获取指定元素的索引
# 通过index()方法获取
# lst=['hello','world',98,'hello']
# print(lst.index('hello'))
# # 当列表中含有多个被索引元素时，只返回第一个索引编号
# print(lst.index('python'))
# 不存在时会报错
# print(lst.index('hello',1,4))
# 可以指定头和尾索引号进行查找

# Chp 49 获取列表中指定元素
# 使用指定索引，正向为正，逆向为负
# lst=['hello','world',98,'hello']
# print(lst[2])
# print(lst[-3])

# Chp 50 获取列表中的多个元素
# 使用切片操作
# [start:stop:step]
# 切片的结果是原列表的拷贝
# lst=['hello','world',98,10,20,30,40]
# print(id(lst[1:6:1]))
# print(lst[1:6:1])
# print(lst[1:6:2])
# print(id(lst))
# 当步长为负数是，切片的第一个元素默认为列表的第一个元素
# print(lst[::-1])

# Chp 51 列表元素的判断和遍历
# 使用in 和not in
# lst=[10,20,'python','hello']
# print(10 in lst)
# print(100 in lst)
# 使用for in 循环遍历列表
# for item in lst:
#     print(item)

# Chp 52 列表元素的增加操作
# 使用方法append()在列表的末尾添加一个元素
# lst=[10,20,'python','hello']
# lst.append(100)
# print(lst)
# 并且标识相同，即是同一个列表的更改
#  使用方法extend()在列表末尾添加至少一个元素
# lst2=[10,20]
# lst.append(lst2)
# print(lst)
# lst.extend(lst2)
# print(lst)
# 使用insert()在列表当中插入元素
# lst.insert(1,90)
# print(lst)
# 使用切片在列表任意位置上添加任意个元素
# lst[1:]=lst2
# print(lst)
# 从指定的位置开始，到指定的位置结束切除原本元素并添加新元素

# Chp 53 列表元素的删除操作
# 使用remove()方法删除一个指定的元素，元素重复时只删除第一个,不存在会报错
# lst=[10,20,30,41,50,30]
# lst.remove(30)
# print(lst)
# 使用方法pop()删除一个指定索引位置上的元素，不指定则删除最后一个元素，索引不存在会报错
# lst.pop(2)
# print(lst)
# 使用切片一次可以删除指定位置的多个元素，但是实际上是产生一个新列表
# newlist=lst[1:3]
# 使用空列表可以避免产生一个新列表
# lst[1:3]=[]
# 使用方法clear()可以清空一个列表
# lst.clear()
# 使用语句del可以删除一个列表
# del lst

# Chp 54 列表元素的修改操作
# 一次修改一个值
# lst=[10,20,30,40,50,60]
# lst[2]=100
# print(lst)
# # 为指定的切片赋予一个新值
# lst[1:3]=[200300,400,300]
# print(lst)

# Chp 55 列表元素的排序操作
# 使用方法sort()，可以将列表中所有元素默认按照从小到大的顺序进行排序，可以指定reverse=True，进行降序排序
# lst=[20,30,40,50,98,2,64,22]
# print(lst,id(lst))
# lst.sort()
# print(lst,id(lst))
# lst.sort(reverse=True)
# print(lst)
# 使用内置函数sorted()，可以指定revers=True，进行降序排序，原列表不发生改变
# print(lst,id(lst))
# newlist=sorted(lst)
# print(newlist)
# newlist2=sorted(lst,reverse=True)
# print(newlist2)

# Chp 56 列表生成式
# 意为生成列表的公式
# 语法格式
# [i*i(自定义变量的函数表达式） for i（自定义变量） in range(a,b)(生成长度)]
# lst=[i for i in range(1,10)]
# print(lst)
# lst2=[i*2 for i in range(1,6)]
# print(lst2)

# Chp 57 什么是字典
# 字典是Python内置的数据结构，是一个可变序列，使用{}定义
# 以键值对的方式存储数据，字典是一个无序的序列
# scores={'zhangsan':100,'lisi':98,'wangwu':45}
# 在往字典中存储数据时，会经过哈希函数计算后得到在字典中的位置hash(key)
# 字符串序列str即为不可变序列,可以作为key

# Chp 58 字典的实现原理
# 字典是根据key查找所对应的value的位置

# Chp 59 字典的创建
# 第一种：scores={'zhangsan':100,'lisi':98,'wangwu':45}
# 第二种：dict(name='jack',age=20)
# scores={'zhangsan':100,'lisi':98,'wangwu':45}
# print(scores)
# print(type(scores))
# 创建空字典
# dic={}

# Chp 60 字典元素的获取
# scores={'zhangsan':100,'lisi':98,'wangwu':45}
# print(scores['zhangsan'],scores['chenliu'])获取不存在的元素会报错
# print(scores.get('zhangsan'),scores.get('chenliu'))获取不存在的元素输出none
# print(scores.get('maqi',99))99是查找到不存在的值时的默认输出值（替换none）

# Chp 61 字典元素的常用操作
# 使用in not in 判断值在字典中存不存在
# scores={'zhangsan':100,'lisi':98,'wangwu':45}
# print('zhangsan' in scores)
# 使用del删除指定的键值对
# del scores['zhangsan']
# 使用clear()方法清空字典中所有的元素
# scores.clear()
# 新增元素
# scores['chenliu']=98
# 修改元素
# scores['chenliu']=100
# print(scores)

# Chp 62 获取字典视图
# 使用key()方法获取字典中所有的的key
# scores={'zhangsan':100,'lisi':98,'wangwu':45}
# keys=scores.keys()
# print(keys)
# print(type(keys))
# 将所有的key所成的视图转换成列表
# print(list(keys))
# 使用value()方法获取字典中所有的值
# values=scores.values()
# print(values)
# print(type(values))
# 同样可以用list()转换为列表
# 使用items()方法获取所有的键值对
# items=scores.items()
# print(items)
# print(type(items))
# 同样可以转换为列表，转换后列表中元素由元组组成

# Chp 63 字典元素的遍历
# scores={'zhangsan':100,'lisi':98,'wangwu':45}
# for item in scores:
#     print(item,scores[item],scores.get(item))

# Chp 64 字典的特点
# key值不允许重复,value可以重复
# d={'name':'zhangsan','nikename':'zhangsan'}
# print(d)
# 字典中的元素是无序的(python 3.6 之后变成有序，尚未学习)
# 字典可以根据需要动态伸缩
# 字典会浪费较多的内存，是一种使用空间换时间的数据结构

# Chp 65 字典生成式
# items=['fruits','books','others']
# prices=[96,78,85]
# print(list(zip(items,prices)))
# 使用内置函数zip()将可迭代的对象最为参数，将对象中对应的元素打包成一个元组，然后返回由这些元组组成的列表
# 再通过字典生成式让这两个列表第一个作为键，第二个作为值生成字典
# d={item:price for item,price in zip(items,prices)}
# d2={item.upper():price for item,price in zip(items,prices)}将item换成大写
# 还有方法lower()全部改小写，captitalize()首字母大写，title()每个单词首字母大写
# print(d)
# print(d2)
# 方法二(弹幕版)
# d=dict(zip(items,prices))
# print(d)

# Chp 66 什么是元组
# 元组是Python内置的数据结构之一，是一个不可变序列
# 可变序列 列表，字典
# 不可变序列 元组，字符串

# Chp 67 元组的创建方式
# t=('python','hello',98)
# 小括号可以省略，只包含一个元素的元组需要使用小括号和逗号
# t=('python',)
# print(t)
# print(type(t))
# 第二种方式
# t2=tuple(('python','hello',98))
# 空元组
# t=()
# t=tuple()

# Chp 68 为什么要把元组设计成不可变序列
# 在多任务环境下，同时操作对象时不需要加锁
# 因此，在程序中尽量使用不可变序列
# 注意：
# 元组当中存储的是对象的引用
# 如果元组当中对象本身是不可变对象，则不能再引用其他对象
# 如果元组中对象是可变对象，则可变对象的引用不允许改变，但是数据可以改变
# 意思是说，元组中每一个索引指向的对象都是固定不可更改的，但是可以对指向的对象进行更改
# t=(10,[20,30],9)
# print(t)
# print(type(t))
# print(t[0],type(t[0]),id(t[0]))
# print(t[1],type(t[1]),id(t[1]))
# print(t[2],type(t[2]),id(t[2]))
# 尝试更改元组
# t[1]=100
# 报错
# 尝试修改列表
# t[1].append(100)
# print(t,id(t[1]))

# Chp 69 元组的遍历
# t=('python','world',98)
# 第一种获取方式，索引
# print(t[1])
# 第二种获取方式，遍历
# for item in t:
#     print(item)

# Chp 70 什么是集合
# python内置的数据结构，与列表，字典一样属于可变序列
# 集合是没有value的字典
# 存储地址也是通过哈希函数计算集合中的元素确定
# 因此，定义类型与字典十分相似，性质也十分相似
# s={'python','hello',98}
# s1={2,3,44,5,5,4,6,2}
# print(s1)
# 集合中的元素也不允许重复
# 第二种创建方式,使用内置函数set()
# s2=set(range(6))
# print(s2)
# s3=set([1,5,6,9,'hello'])
# print(s3,type(s3))
# s4=set((1,5,4,6,954))
# print(s4)
# s5=set('python')
# print(s5)
# s6=set({1,2,55,55,3,6})
# print(s6)
# 创建空集合
# s7=set()
# 如果用{}定义是空字典
# 集合的遍历
# for item in s:
#     print(item)

# Chp 71 集合的相关操作
# 集合元素的判断操作
# 使用in 或者not in
# s={10,20,30,40}
# print(10 in s)
# print(50 in s)
# 集合元素的新增操作
# 使用add()方法为集合中新增一个元素
# s.add(80)
# print(s)
# 使用update()方法添加至少一个元素，括号内列表，元组，集合都可以
# s.update([200,300,400])
# print(s)
# 集合元素的删除操作
# 使用remove()方法一次可以删除一个元素，指定元素不存在时抛出异常
# s.remove(10)
# print(s)
# 使用discard()方法，一次删除一个指定元素，不存在时不抛出异常
# s.discard(200)
# print(s)
# 使用pop()方法，一次删除一个任意元素(随机)(据说删除元素是从栈顶开始删，即内存位置从小往大，与哈希算出来的内存位置有关)
# s.pop()
# print(s)
# 使用clear()方法，清空集合
# s.clear()
# print(s)

# Chp 72 集合间的关系
# 两个集合是否相等可以使用==与!=判断
# s1={10,20,30,40}
# s2={30,40,20,10}
# print(s1==s2)
# 一个集合是否是另一个集合的子集，可以用方法issubset()判断
# s1={10,20,30,40,50,60}
# s2={10,20,30}
# s3={10,20,70}
# print(s2.issubset(s1))
# print(s3.issubset(s1))
# 一个集合是否是一个集合的超集，可以用方法issuperset()判断
# print(s1.issuperset(s2))
# 两个集合是否没有交集，可以用方法isdisjoint()判断,False就是有交集
# print(s2.isdisjoint(s3))

# Chp 73 集合的数学操作
# 两个集合的交集
# 交集
# s1={10,20,30,40}
# s2={20,30,40,50,60}
# print(s1.intersection(s2))
# print(s1 & s2)
# 并集
# print(s1.union(s2))
# print(s1 | s2)
# 差集
# print(s1.difference(s2))
# print(s1-s2)
# 对称差集
# print(s1.symmetric_difference(s2))
# print(s1 ^ s2)

# Chp 74 集合生成式
# 将列表生成式中的[]改为{}即可
# s={i for i in range(0,6)}
# print(s)

# Chp 75 字符串的创建与驻留机制
# 字符串是Python当中的一种基本数据类型，是一个不可变的字符序列
# 字符串驻留机制是指，python中对于相同字符串仅保留一份的方法
# 当一个字符串被创建之后，再创建相同字符串时，python会将原本字符串的地址赋给新的变量，即后续变量的指针指向的是同一个地址(用C的方法解释)
# a='python'
# b="python"
# c='''python'''
# print(id(a),id(b),id(c))
# 字符串驻留机制的几种模式(交互模式)(windows cmd或者python自带的idle)
# 字符串的长度为0或者1时
# 符合标识符的字符串(仅含有字母数字下划线的字符串)
# 字符串只在编译时驻留，而非运行时
# a='abc'
# b='a'+'bc'
# c=''.join(['a','bc'])
# print(a is b)
# print(a is c)
# 因为a和b是在代码编译的时候就确定了为'abc'，而c是要运行程序后使用方法join()才会赋值为'abc'
# 所以a,b会有驻留机制，c没有
# [-5,256]之间的整数数字
# 可以import sys，使用sys.intern()方法强制驻留(交互模式下)
# import sys
# a='abc%'
# b='abc%'
# print(a is b)
# a=sys.intern(b)
# print(a is b)
# pycharm对于字符串进行了优化处理，都会驻留
# 字符串驻留机制的优缺点
# 当需要值相同的字符串时，可以直接从字符串池中拿来使用，避免频繁地创建和销毁，提升效率和节约内存
# 在进行字符串拼接的时候建议使用join方法，因为join方法是先计算出所有字符的长度，然后再创建一次对象，效率要比+更高

# Chp 76 字符串的查询操作
# 字符串查询操作的方法
# index()查找子串第一次出现的位置，如果不存在则抛出错误
# rindex()查找子串最后一次出现的位置，如果查找的子串不存在时抛出错误
# find()查找子串第一次出现的位置，不存在则返回-1
# rfind()查找子串最后一次出现的位置，不存在则返回-1
# s='hello,hello'
# print(s.index('lo'))
# print(s.find('lo'))
# print(s.rindex('lo'))
# print(s.rfind('lo'))
# print(s.find('k'))

# Chp 77 字符串的大小写转换操作
# upper()方法所有字符转换为大写
# lower()全部改小写
# captitalize()第一个字符大写其他转为小写
# title()每个单词首字符大写其他小写
# swapcase()把所有小写转大，大写转小
# s='hello,python'
# a=s.upper()
# print(a,id(a))
# print(s,id(s))
# a2=s.lower()
# a3=s.capitalize()
# a4=s.swapcase()
# a5=s.title()
# print(a2,a3,a4,a5)

# Chp 78 字符串内容对齐操作
# center()方法 居中对齐，第一个参数指定宽度，第二个参数指定填充符
# 第二个参数可选，默认是空格，若设置宽度小于实际宽度则返回原字符串
# ljust()方法 左对齐，第一个参数指定宽度，第二个参数指定填充符
# 第二个参数可选，默认是空格，若设置宽度小于实际宽度则返回原字符串
# rjust()方法 右对齐，第一个参数指定宽度，第二个参数指定填充符
# 第二个参数可选，默认是空格，若设置宽度小于实际宽度则返回原字符串
# zfill()方法 右对齐，左边用0填充
# 该方法只接受一个参数，用于指定字符串的宽度，若指定的宽度小于等于字符串的长度则返回字符串本身
# s='hello,python'
# print(s.center(20,'*'))
# print(s.ljust(20,'*'))
# print(s.rjust(20,'*'))
# print(s.zfill(20))
# print('-8910'.zfill(9))
# 特殊用法，碰到+-会把加减置于最前

# Chp 79 字符串的劈分
# split()方法 从字符串的左边开始劈分，默认的劈分字符是空格字符串，返回的值都是一个列表
# 可以通过参数sep指定劈分字符串的劈分符
# 通过参数maxsplit指定劈分字符串的最大劈分次数，经过最大劈分次数后，剩余的子串会单独作为一部分
# rsplit()方法 从字符串的左边开始劈分，默认的劈分字符是空格字符串，返回的值都是一个列表
# 可以通过参数sep指定劈分字符串的劈分符
# 通过参数maxsplit指定劈分字符串的最大劈分次数，经过最大劈分次数后，剩余的子串会单独作为一部分
# s='hello world python'
# lst=s.split()
# print(lst)
# s1='hello|world|python'
# print(s1.split(sep='|'))
# print(s1.split(sep='|',maxsplit=1))

# Chp 80 字符串判断的相关方法
# isidentifier() 判断指定的字符串是不是合法的标识符
# isspace() 判断指定的字符串是否全部由空白字符组成(回车，换行，水平制表符)
# isalpha() 判断指定的字符串是否全部由字母组成
# isdecimal() 判断指定字符串是否全部由十进制的数字组成
# isnumeric() 判断指定的字符串是否全部由数字(中文大写数字，罗马数字都算)组成
# isalnum() 判断指定字符串是否全部由字母和数字组成
# s='hello,python'
# print(s.isidentifier())
# print('hello'.isidentifier())
# print(s.isspace())
# print(' \t'.isspace())
# print('abc'.isalpha())
# print(s.isalpha())
# print('123'.isdecimal())
# print(s.isdecimal())
# print('123'.isnumeric())
# print('123四'.isnumeric())
# print(s.isalnum())
# print('张三123'.isalnum())
# print('张三123'.encode('utf-8').isalnum())使用utf-8汉字编码就不会把汉字识别成字母

# Chp 81 字符串的替换和合并
# replace() 第一个参数指定被替换的子串，第二个参数指定替换子串的字符串，该方法返回替换后得到的字符串
# 替换前的字符串不发生变化，调用该方法时可以通过第三个参数指定最大替换次数
# join() 将列表或元组中的字符串合并成一个字符串
# s='hello,python'
# print(s.replace('python','java'))
# s1='hello,python,python,python'
# print(s1.replace('python','java',2))
# lst=['java','hello','python']
# print('|'.join(lst))
# print(''.join(lst))
# t=('hello','java','python')
# print(''.join(t))
# print('*'.join('python'))
# 此时会将python作为字符串序列连接

# Chp 82 字符串的比较操作
# 可以使用运算符>,>=,<,<=,==,!=比较
# 比较规则：首先比较两个字符串中的第一个字符，如果相等则继续比较下一个字符，依次比较下去
# 直到两个字符串中的字符不相等时，其比较结果就是两个字符串的比较结果
# 比较原理：两个字符进行比较时，比较的是其ordinal value原始值，调用内置函数ord可以得到指定字符的原始值
# 与ord对应的是chr，调用chr可以指定原始值得到对应的字符
# print('apple'>'app')
# print('apple'>'banana')
# print(ord('a'),ord('b'))
# print(chr(97),chr(98))
# print(ord('邹'))
# print(chr(37049))
# ==与is的区别
# ==比较的是值，is比较的是内存地址

# Chp 83 字符串的切片操作
# 字符串是不可变类型
# 切片操作将产生新的对象
# s='hello,python'
# s1=s[:5]
# print(s1)
# s2=s[6:]
# print(s2)
# s3=s1+'!'+s2
# print(s3)
# 标准切片
# s=[start:end:step]
# 当步长为负数的时候，从后往前切片

# Chp 84 # 格式化字符串
# 在某个固定格式的字符串中有部分可变内容，则我们需要格式化字符串
# 第一种方式
# 使用%作为占位符，%s代表字符串等，与c语言中类似
# 第二种方式
# 使用{}作为占位符
# 第三种方式
# 在格式化的字符串前加f
# name='张三'
# age=20
# print('我叫%s,今年%d岁' % (name,age))
# print('我叫{0}，今年{1}岁'.format(name,age))
# print((f'我叫{name},今年{age}岁'))
# print('%10d' % 99)
# print('%.3f' % 3.1415926)
# print('%10.3f' % 3.1415926)
# 此处和c语言类似，10控制宽度，.3f控制精度
# print('{0:.3}'.format(3.1415926))
# 表示一共是三位数
# print('{0:.3f}'.format(3.1415926))
# 表示保留三位小数
# print('{0:10.3f}'.format(3.1415926))
# 表示宽度为10，保留三位小数

# Chp 85 字符串的编码与解码
# 编码：将字符串转换为二进制数据（比特）
# 解码：将比特转换成字符串类型
# s='天涯共此时'
# print(s.encode(encoding='GBK'))
# 在gbk这种格式中一个中文占两个字节
# print(s.encode(encoding='UTF-8'))
# 在此格式中一个中文占三个字节
# bytes=s.encode(encoding='GBK')
# print(bytes.decode(encoding='GBK'))

# Chp 86 函数的定义与调用
# 函数的创建
# def 函数名([输入参数]):
#     函数体
#     [return xxx]
# def calc(a,b):
#     c=a+b
#     return c
# print(calc(10,20))

# Chp 87 函数的参数传递
# def calc(a,b)中的a,b是两个函数的形参
# calc(10,20)中的10,20是两个实际参数值
# 按对应位置传递参数叫位置实参
# calc(b=10,a=20)
# 按照对应参数名传递参数叫关键字实参
# 在参数过多时可以按照关键字只对重要的参数赋值，其余默认初始值

# Chp 88 函数参数传递的内存分析
# def fun(arg1,arg2):
#     print('arg1=',arg1)
#     print('arg2=',arg2)
#     arg1=100
#     arg2.append(10)
#     print('arg1=',arg1)
#     print('arg2=',arg2)
# n1=11
# n2=[22,33,44]
# print(n1)
# print(n2)
# fun(n1,n2)
# print(n1)
# print(n2)
# 因为arg1是不可变的，中间更改实际上是让函数中的形参arg1指向了另一个100而不是n1，但是不对外部的实际参数产生影响
# 但是arg2是可变的，对arg2的更改并没有改变arg2的地址，arg2还是=n2，故而可以对实际参数产生影响

# Chp 89 函数的返回值
# 函数返回多个值时，期结果为元组
# def fun(num):
#     odd=[]
#     even=[]
#     for i in num:
#         if i%2:
#             odd.append(i)
#         else:
#             even.append(i)
#     return odd,even
# lst=[10,29,34,23,44,53,55]
# print(fun(lst))

# Chp 90 默认值参数
# 函数定义时可以给形参设置默认值，只有与默认值不符的时候才会传递实参
# def fun(a,b=10):
#     print(a,b)
# fun(100)
# fun(20,30)

# Chp 91 个数可变的位置形参与关键字形参
# 定义函数时，无法实现确定传递的位置实参的个数时，使用可变的未知参数*
# 输出结果为一个元组
# def fun(*args):
#     print(args)
# fun(10)
# fun(10,20,30)
# 定义函数时，无法实现确定传递的关键字实参的个数时，使用可变的未知参数**
# 输出结果为一个字典
# def fun1(**args):
#     print(args)
# fun1(a=10)
# fun1(a=20,b=30,c=40)
# def fun2(*args,**args1):
#     pass
# 在一个函数的定义过程中，既有可变的关键字形参和位置形参，要求位置形参放在前面，关键字形参放在后面

# Chp 92 函数的参数总结
# 将列表中的每个元素都转换为位置实参，使用*
# def fun(a,b,c):
#     print(a,b,c)
# lst=[10,20,30]
# fun(*lst)
# 将字典的每个键值对都转换为关键字实参，使用**
# dic={'a':1,'b':2,'c':3}
# fun(**dic)
# def fun1(a,b,*,c,d):
#     pass
# 使*之后的参数只能使用关键字传递实参

# Chp 93 变量的作用域
# 根据变量的有效范围可分为：
# 局部变量：在函数内定义并使用的变量，只在函数内部有效，局部变量使用global声明，这个变量就会变成全局变量
# 全局变量：函数体外定义的变量，可作用于函数内外

# Chp 94 递归函数
# 在一个函数体内部调用该函数本身，称为递归
# 递归的组成部分：递归调用与终止条件
# 递归的调用过程：
# 每递归调用一次函数，都会在栈内存分配一个栈帧
# 每执行完一次函数，都会释放相应的空间
# 缺点：占用内存多，效率低下
# 优点：思路和代码简单
# def fac(a):
#     if a>1:
#         return a*fac(a-1)
#     else:
#         return a
# print(fac(6))

# Chp 95 斐波那契数列
# def Fibonacci(n):
#     res=[]
#     if n==1:
#         res=1
#     elif n==2:
#         res=1
#     else:
#         res=Fibonacci(n-1)+Fibonacci(n-2)
#     return res
# print(Fibonacci(6))

# Chp 96 Bug的由来和分类

# Chp 97 Bug的常见类型 语法错误
# 粗心导致的语法错误 SyntaxError

# Chp 98 Bug的常见类型 错误点不熟悉
# 索引越界 IndexError
# 方法使用错误 NameError

# Chp 99 Bug的常见类型 思路不清导致错误
# 解决方法：
# 1.使用print函数打印每次执行的结果
# 2.使用井号注释代码
# 3.使用调试断点一步一步走

# Chp 100 Bug的常见类型 被动掉坑
# 程序代码逻辑没有错误，因为用户的错误操作和意外状况导致崩溃
# 经典的测试员笑话（bushi
# 采用python的异常处理机制try-except语句，在异常出现时及时捕获，然后内部消化让程序继续运行
# try:
#    n1=int(input('请输入一个整数'))
#    n2=int(input('请输入一个整数'))
#    res=n1/n2
#    print('结果为',res)
# except ZeroDivisionError:
#     print('除数不能为0')
# 把可能会出问题的代码放进try里，可能的对应的报错放进except里面
# 捕获异常的顺序按照先子类后父类的顺序，为了避免遗漏可能出现的异常，可以在多个except结构最后增加 BaseException

# Chp 101 try-except-else结构
# 如果try块中没有抛出异常，则执行else块，否则执行except块
# try:
#    n1=int(input('请输入一个整数'))
#    n2=int(input('请输入一个整数'))
#    res=n1/n2
# except BaseException as e:
#     print('出错了',e)
# else:
#     print('结果为',res)
# try-except-else-finally结构
# finally块无论是否发生异常都会被执行，能用来释放try块申请的资源

# Chp 102 python中常见的异常类型
#  ZeroDivisionError 被0除异常
# IndexError 索引异常
# KeyError 映射中没有这个键
# NameError 变量名(对象未初始化)异常
# SyntaxError 语法错误
# ValueError 传递参数异常

# Chp 103 traceback模块的使用
# 使用traceback模块打印异常信息
# import traceback
# try:
#     print(1/0)
# except:
#     traceback.print_exc()

# Chp 104 Pycharm开发环境的调试
# 使用断点，让程序运行到某一处时中断并挂起
# i=1
# while i<10:
#     print(i)
# 先按步入一步一步走判断bug

# Chp 105 面向过程与面向对象
# 面向过程编程：事物比较简单，使用线性的思维去解决问题
# 面向对象编程：事物比较复杂，使用简单的线性思维无法解决问题
# 面向过程逻辑清晰，在底层运用较多，微观操作上运用多
# 面向对象在处理具体事物上比较容易理解，方便宏观分析整个系统

# Chp 106 类与对象
# class 定义一个类，是类似事物组成群体的统称
# 不同的数据类型属于不同的类，如字符串类型都是str类
# 对象是一个类下的相似的不同的个体，称为对象

# Chp 107 类的创建
# class Student:
#     native_place='北京' #直接写在类里的变量，成为类属性
#     #称为初始化方法
#     def __init__(self,name,age):
#         self.name=name #self.name称为实例属性，进行了一个赋值的操作，将局部变量name的值赋给实例属性
#         self.age=age
#
#     def eat(self):
#         print('1') #在类中定义的函数，称为方法，此处叫实例方法
#     @staticmethod
#     def method():
#         print('2') #使用@staticmethod修饰的方法，称为静态方法
    # @classmethod
    # def cm(cls):
    #     print('3') #使用@classmethod修饰的方法称为类方法

# Student是类名，由一个或多个单词组成，一般按照每个单词首字母大写的大驼峰规则
# print(id(Student))
# print(type(Student))
# print(Student)
# 对象拥有地址，类型和值
# 类的组成
# 类属性
# 实例方法
# 静态方法
# 类方法

# Chp 108 对象的创建
# 对象的创建又称为类的实例化
# 本章笔记与上章创建的类联动
# stu=Student('张三',20)
# print(id(stu))
# print(type(stu))
# print(stu)
# 输出stu对象的值的时候实际上是输出stu对象16进制的地址
# Student.eat(stu)
# stu.eat()
# 都是调用eat方法
# print(stu.name)
# print(stu.age)

# Chp 109 类属性，类方法，静态方法
# 本章笔记与107章创建的类联动
# 类属性可以被类中的所有对象共享
# print(Student.native_place)
# stu=Student('张三',20)
# stu1=Student('李四',30)
# print(stu.native_place)
# print(stu1.native_place)
# Student.native_place='天津'
# print(stu.native_place)
# print(stu1.native_place)
# 类方法，访问类属性，可用于修改类属性
# Student.cm()
#静态方法，访问静态参数
# Student.method()

# Chp 110 动态绑定属性和方法
# class Student:
#     def __init__(self,name,age):
#         self.name=name
#         self.age=age
#     def eat(self):
#         print(self.name+'在吃饭')
# stu1=Student('张三',20)
# stu2=Student('李四',30)
# 为stu2动态绑定性别
# stu2.gender='女'
# print(stu1.name,stu1.age)
# print(stu2.name,stu2.age,stu2.gender)
# 为stu1动态绑定方法
# def show():
#     print('1')
# stu1.show=show
# stu1.show()

# Chp 111 封装的实现方式
# 封装可以提高程序的安全性
# 将数据(属性)和行为(方法)包装到类对象中，在方法内部对属性进行操作，在类对象的外部调用方法
# 这样无需关心方法内部的具体细节，从而隔离复杂度
# 如果该属性不希望在类对象的外部访问，前面使用__
# class Car:
#     def __init__(self,brand):
#         self.brand=brand
#     def start(self):
#         print('汽车启动')
# car=Car('宝马')
# car.start()
# print(car.brand)
# 封装的实现
# class Student
#     def __init__(self,age):
#         self.set_age(age)
#     def get_age(self):
#         return self.__age
# # 年龄不希望在类的外部被使用，所以加__
#     def set_age(self,age):
#         if 0<=age<=120:
#             self.__age=age
#         else:
#             self.__age=18
# 使用函数dir()可以获取类中的属性和方法列表
# 继承提高代码的复用性
# 多态提高程序的可扩展性和可维护性

# Chp 112 继承及其实现方式
# 格式：
# class 子类类名(父类1,父类2.....):
#     pass
# python支持多继承，即多个父类
# 如果没有继承任何类，则默认继承object
# 使用super()调用父类的方法
# class Person:
#     def __init__(self,name,age):
#         self.name=name
#         self.age=age
#     def info(self):
#         print(self.name,self.age)
# class Student(Person):
#     def __init__(self,name,age,stu_no):
#         super().__init__(name,age)
#         self.stu_no=stu_no
# stu=Student('张三',20,'1001')
# stu.info()

# Chp 113 方法重写
# 在子类中重新对父类的方法编写以达成需求
# class Person:
#     def __init__(self,name,age):
#         self.name=name
#         self.age=age
#     def info(self):
#         print(self.name,self.age)
# class Student(Person):
#     def __init__(self,name,age,stu_no):
#         super().__init__(name,age)
#         self.stu_no=stu_no
#     def info(self):
#         super().info()
#         print(self.stu_no)
# stu=Student('张三',20,'1001')
# stu.info()

# Chp 114 object类
# class Student:
#     def __init__(self,name,age):
#         self.name=name
#         self.age=age
#     def __str__(self):
#         return '我的名字是{0}，今年{1}岁'.format(self.name,self.age)
# stu=Student('张三',20)
# print(dir(stu))
# print(stu)

# Chp 115 多态的实现、
# 多态指的是即使不知道一个变量所引用的对象到底是什么类型，仍然可以通过这个变量调用方法
# 在运行过程中根据变量所引用对象的类型，动态决定调用哪个对象中的方法
# class Animal:
#     def eat(self):
#         print('动物要吃东西')
# class Dog(Animal):
#     def eat(self):
#         print('狗吃肉')
# class Cat(Animal):
#     def eat(self):
#         print('猫吃鱼')
# class Human:
#     def eat(self):
#         print('人吃五谷杂粮')
# def fun(obj):
#     obj.eat()
# fun(Cat())
# fun(Dog())
# fun(Animal())
# fun(Human())

# Chp 116 特殊属性
# __dict__获得类对象或实例对象所绑定的所有属性和方法的字典
# class A:
#     pass
# class B:
#     pass
# class C(A,B):
#     def __init__(self,name,age):
#         self.name=name
#         self.age=age
# # 创建c类的对象
# x=C('Jack',20)
# print(x.__dict__)
# print(C.__dict__)
# print(x.__class__)#输出了对象所属的类
# print(C.__bases__) #输出c类父类类型的元组
# print(C.__base__) #输出C类的首个父类(基类)
# print(C.__mro__) #查看类的层次结构
# print(A.__subclasses__()) #查看一个类的子类的列表

# Chp 117 特殊方法
# a=20
# b=100
# c=a+b
# print(c)
# d=a.__add__(b)
# print(d)
# class Student:
#     def __init__(self,name):
#         self.name=name
#     def __add__(self, other):
#         return self.name+other.name
#     def __len__(self):
#         return len(self.name)
# stu1=Student('zhangsan')
# stu2=Student('lisi')
# s=stu1+stu2
# # 在student类中重定义了__add__()特殊方法
# print(s)
# lst=[11,22,33,44]
# print(len(lst))
# print(lst.__len__())
# # 重定义了__len__()特殊方法
# print(len(stu1))

# Chp 118 __new__()与__init__()
# class Person(object):
#     def __new__(cls, *args, **kwargs):
#         print('__new__被调用执行了，cls的id值为{0}'.format(id(cls)))
#         obj=super().__new__(cls)
#         print('创建的对象的id记为{0}'.format(id(obj)))
#         return obj
#     def __init__(self,name,age):
#         print('__init__被调用了，self的id值为{0}'.format(id(self)))
#         self.name=name
#         self.age=age
# print('object这个类对象的id{0}'.format(id(object)))
# print('person这个类对象的id{0}'.format(id(Person)))
# p1=Person('张三',20)
# print('p1这个实例对象的id{0}'.format(id(p1)))

# Chp 119 类的赋值与浅拷贝
# 变量的赋值操作：形成两个变量，但实际上指向同一个对象
# class Cpu:
#     pass
# class Disk:
#     pass
# class Computer:
#     def __init__(self,cpu,disk):
#         self.cpu=cpu
#         self.disk=disk
# # 变量的赋值
# cpu1=Cpu()
# cpu2=cpu1
# print(cpu1)
# print(cpu2)
# 浅拷贝是指对象包含的子对象内容不拷贝，因此源对象与拷贝对象会引用同一个子对象
# disk=Disk()
# computer=Computer(cpu1,disk)
# import  copy
# computer2=copy.copy(computer)
# print(computer,computer.cpu,computer.disk)
# print(computer2,computer2.cpu,computer2.disk)

# Chp 120 深拷贝
# 使用deepcopy()函数，递归拷贝对象中的子对象
# computer3=copy.deepcopy(computer)
# print(computer3,computer3.cpu,computer3.disk)

# Chp 121 什么是模块
# 模块英文为modules
# 一个模块中可以包含N多个函数
# 在python中一个扩展名为.py的文件就是一个模块
# 使用模块的好处
# 方便其他程序和脚本的导入并使用
# 避免函数名和变量名冲突
# 提高代码的可维护性
# 提高代码的可复用性

# Chp 122 自定义模块
# 新建一个.py文件，名称尽量不要与python自带的标准模块名称相同
# import  模块名 [as别名]
# from 模块名称 import 函数/变量/类
# import math
# print(id(math))
# print(type(math))
# print(math)
# print(math.pi)
# print(dir(math))
# from math import pi
# 自定义模块导入需要勾上mark directory as sources root
# import test2
# 或者from  import

# Chp 123 以主程序形式运行
# 在每个模块的定义中都包括一个记录模块名称的变量__name__，程序可以检查该变量
# 以确定他们在哪个模块中执行。如果一个模块不是被导入到其他程序中执行
# 那么他可能在解释器的顶级模块中执行
# 顶级模块中的name变量的值为__main__
# 在一个模块中加入
# if __name__=='__main__':
# 则可以让其在以主程序运行的时候才运行if后的代码

# Chp 124 python中的包
# 包是一个分层次的目录结构，它将一组功能相近的模块组织在一个目录下
# 作用是使代码规范，同时避免模块名称冲突
# 包与目录的区别
# 包含__init__.py文件的目录称为包
# 目录里通常不包含这个文件
# 包的导入
# import 包名.模块名
# 新建 python软件包
# 导入带有包的模块时注意
# import package(包名)
# import moduel(模块名)
# from package import moduel
# from package.moduel import a

# Chp 125 python中常用的内置模块
# sys 与python解释器和环境操作相关的标准库
# import sys
# import time
# print(sys.getsizeof(24))
# 获取对象所占内存的大小（字节
# time 与时间相关各种函数的标准库
# import time
# print(time.time())
# # 输出秒数
# print(time.localtime(time.time()))
# 将秒数转换为年月日星期
# os 提供了访问操作系统服务的标准库
# calendar 提供与日期相关的各种函数的标准库
# urllib 用于读取网上服务器的数据标准库
# import urllib.request
# print(urllib.request.urlopen('http://www.baidu.com').read())
# 读取百度网页信息
# json 用于使用json序列化和反序列化对象
# re 用于在字符串中执行正则表达式匹配和替换
# math 提供标准算数运算函数的标准库
# demical 用于进行精确控制运算精度，有效位数和四舍五入操作的十进制运算
# logging 提供了灵活的记录事件，错误，警告和调试信息等日志信息的功能

# Chp 126 第三方模块的安装与使用
# pip install 模块名 大法好
# 导入 import 模块名

# Chp 127 编码格式介绍
# python解释器使用的是unicode
# .py文件在磁盘上使用utf-8存储
#encoding=GBK
# print('你好')

# Chp 128 文件读写的原理
# 文件的读写俗称IO操作
# python读写流程
# 打开或新建文件
# 读写文件
# 关闭资源
# 内置函数open()创建文件对象
# file=open(filename [,mode,encoding])
# file=open('a.txt','r')
# print(file.readlines())
# 读取文件中的内容输出一个列表
# file.close()

# Chp 129 常用的文件打开模式
# file=open('a.txt','w')
# file.write('helloworld')
# file.close()
# r 以只读模式打开文件，文件的指针将会放在文件的开头
# w 以只写的模式打开文件，如果文件不存在则创建，如果文件存在则覆盖内容，文件指针在文件的开头
# a 以追加模式打开文件。如果文件不存在则创建，文件指针在开头，如果存在则在文件末尾追加内容，文件指针在源文件末尾
# b 以二进制方式打开文件，不能单独使用，需要和其他模式一起使用，如rb（用来读写照片，视频，音频等文件
# + 以读写方式打开文件，不能单独使用

# Chp 130 文件对象的常用方法
# read([size])从文件中读取size个字节或者字符的内容，如果省略size则读取全部内容
# readline()从文件中读取一行内容
# readlines()把文本文件中每一行作为独立的字符串对象读取，返回一个字符串对象列表
# write(str)将字符串内容写入文件
# writelines(s_list)将字符串列表写入文本文件，不添加换行符
# seek(offset[,whence])
# 把文件指针移动到新的位置，offset表示相对于whence的位置
# offset为正表示往结束方向移动 ，反之往开始方向移动
# whence不同的值代表不同的含义
# 0从文件头开始计算
# 1从当前位置开始计算
# 2从文件尾开始计算
# tell()返回文件指针的当前位置
# flush()把缓冲区的内容写入文件但不关闭文件
# close()把缓冲区的内容写入文件，同时关闭文件，释放文件对象相关资源

# Chp 131 with语句(上下文管理器)
# with语句可以自动管理上下文资源，不论什么原因跳出with块，都能确保文件正确的关闭，以此释放资源
# with open('a.txt','r') as file:
# 对于实现了特殊方法__enter__(),__exit__()的类对象，称为该类对象遵守了上下文管理器协议
# 这个类的实例对象称为上下文管理器
# 进入时自动调用enter，退出时自动调用exit
# with open('logo.png','rb') as src_file:
#     with open('copy2logo.png','wb') as target_file:
#         target_file.write(src_file.read())
# 使用with语句复制文件

# Chp 132 os模块的常用函
# import os
# os.system('notepad.exe')
# os.system('calc.exe')
# 通过系统命令打开记事本和计算器
# os.startfile('D:\\CloudMusic\\cloudmusic.exe')
# 直接打开exe文件
# getcwd()返回当前的工作目录
# print(os.getcwd())
# listdir()返回指定路径下的文件和目录信息
# print(os.listdir('../Objects'))
# mkdir(path[,mode])创建目录
# os.mkdir('new')
# makedirs(path1/path2...[,mode])创建多级目录
# rmdir(path)删除目录
# os.rmdir('new')
# removedirs(path1/path2....)删除多级目录
# chdir(path)将path设为当前工作目录

# Chp 133 os.path模块操作目录的相关函数
# import os.path
# print(os.path.abspath('1.py'))
# abspath(path)用于获取文件或者目录的绝对路径
# print(os.path.exists('Test.py'))
# exsits(path)用于判断文件或者目录是否存在，如果存在返回True,不存在返回False
# print(os.path.join('E:\\python','demo13.py'))
# join(path,name)将目录与目录或者文件名拼接起来
# print(os.path.split('E:\\python\\demo.py'))
# print(os.path.splitext('python.py'))
# splitext()分离文件名与扩展名
# print(os.path.basename('C:\\Users\\Ilusio\\PycharmProjects\\Practise&Notes\\Test.py'))
# basename(path)从一个目录中提取文件名
# print(os.path.dirname('C:\\Users\\Ilusio\\PycharmProjects\\Practise&Notes\\Test.py'))
# dirname(path)从一个路径中提取文件路径，不包括文件名
# print(os.path.isdir('C:\\Users\\Ilusio\\PycharmProjects\\Practise&Notes'))
# isdir(path)判断是否为路径
# 列出指定目录下的所有的py文件
# 案例
# import os
# path=os.getcwd()
# lst=os.listdir(path)
# for filename in lst:
#     if filename.endswith('.py'):
#         print(filename)
# walk方法可以遍历该目录下包括子目录的所有文件
# import os
# path=os.getcwd()
# lst_files=os.walk(path)
# for dirpath,dirname,filename in lst_files:
    # print(dirpath)
    # print(dirname)
    # print(filename)
    # for dir in dirname:
    #     print(os.path.join(dirpath,dir))
    # for file in filename:
    #     print(os.path.join(dirpath,file))

# Final
